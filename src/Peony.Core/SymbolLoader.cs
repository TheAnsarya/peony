using Pansy.Core;

namespace Peony.Core;

/// <summary>
/// Loads and manages symbols (labels, comments, data definitions) for disassembly
/// Supports common formats: FCEUX .nl files, Mesen .mlb files, JSON, CDL, DIZ, Pansy
/// </summary>
public class SymbolLoader {
	private readonly Dictionary<uint, string> _labels = [];
	private readonly Dictionary<uint, string> _comments = [];
	private readonly Dictionary<uint, DataDefinition> _dataDefinitions = [];
	private readonly Dictionary<(int Bank, uint Address), string> _bankLabels = [];
	private CdlLoader? _cdlLoader;
	private DizLoader? _dizLoader;
	private PansyLoader? _pansyLoader;

	public IReadOnlyDictionary<uint, string> Labels => _labels;
	public IReadOnlyDictionary<uint, string> Comments => _comments;
	public IReadOnlyDictionary<uint, DataDefinition> DataDefinitions => _dataDefinitions;
	public IReadOnlyDictionary<(int Bank, uint Address), string> BankLabels => _bankLabels;

	/// <summary>
	/// Gets the loaded CDL data, if any.
	/// </summary>
	public CdlLoader? CdlData => _cdlLoader;

	/// <summary>
	/// Gets the loaded DIZ data, if any.
	/// </summary>
	public DizLoader? DizData => _dizLoader;

	/// <summary>
	/// Gets the loaded Pansy data, if any.
	/// </summary>
	public PansyLoader? PansyData => _pansyLoader;

	/// <summary>
	/// Load symbols from file (auto-detect format)
	/// </summary>
	public void Load(string path) {
		var ext = Path.GetExtension(path).ToLowerInvariant();

		switch (ext) {
			case ".nl":
				LoadFceuxNl(File.ReadAllText(path));
				break;
			case ".mlb":
				LoadMesenMlb(File.ReadAllText(path));
				break;
			case ".json":
				LoadJson(File.ReadAllText(path));
				break;
			case ".sym":
				LoadGenericSym(File.ReadAllText(path));
				break;
			case ".cdl":
				LoadCdl(path);
				break;
			case ".diz":
				LoadDiz(path);
				break;
			case ".pansy":
				LoadPansy(path);
				break;
			default:
				// Try to auto-detect
				var content = File.ReadAllText(path);
				if (content.TrimStart().StartsWith('{'))
					LoadJson(content);
				else
					LoadGenericSym(content);
				break;
		}
	}

	/// <summary>
	/// Load a CDL (Code/Data Log) file from emulators like FCEUX/Mesen.
	/// </summary>
	/// <param name="path">Path to the CDL file.</param>
	public void LoadCdl(string path) {
		_cdlLoader = CdlLoader.Load(path);

		// Generate labels for subroutine entry points
		foreach (var offset in _cdlLoader.SubEntryPoints) {
			var address = (uint)offset;  // May need address translation
			if (!_labels.ContainsKey(address)) {
				_labels[address] = $"sub_{offset:x4}";
			}
		}
	}

	/// <summary>
	/// Load a DiztinGUIsh (.diz) project file.
	/// </summary>
	/// <param name="path">Path to the DIZ file.</param>
	public void LoadDiz(string path) {
		_dizLoader = DizLoader.Load(path);

		// Import labels from DIZ file
		_dizLoader.ExportToSymbolLoader(this);
	}

	/// <summary>
	/// Load a Pansy (.pansy) metadata file generated by Poppy assembler.
	/// Pansy files contain comprehensive disassembly metadata including
	/// code/data map, symbols, comments, and cross-references.
	/// </summary>
	/// <param name="path">Path to the Pansy file.</param>
	public void LoadPansy(string path) {
		var data = File.ReadAllBytes(path);
		_pansyLoader = new PansyLoader(data);

		// Import symbols from Pansy file (IReadOnlyDictionary<int, string>)
		foreach (var (address, name) in _pansyLoader.Symbols) {
			_labels[(uint)address] = name;
		}

		// Import comments from Pansy file (IReadOnlyDictionary<int, string>)
		foreach (var (address, text) in _pansyLoader.Comments) {
			_comments[(uint)address] = text;
		}
	}

	/// <summary>
	/// Load a Pansy file from raw byte data.
	/// </summary>
	/// <param name="data">The Pansy file bytes.</param>
	public void LoadPansyData(byte[] data) {
		_pansyLoader = new PansyLoader(data);

		// Import symbols (IReadOnlyDictionary<int, string>)
		foreach (var (address, name) in _pansyLoader.Symbols) {
			_labels[(uint)address] = name;
		}

		// Import comments (IReadOnlyDictionary<int, string>)
		foreach (var (address, text) in _pansyLoader.Comments) {
			_comments[(uint)address] = text;
		}
	}

	/// <summary>
	/// Checks if an address/offset is code according to CDL/DIZ/Pansy data.
	/// </summary>
	/// <param name="offset">The ROM file offset.</param>
	/// <returns>True if marked as code, null if no CDL/DIZ/Pansy loaded.</returns>
	public bool? IsCode(int offset) {
		if (_cdlLoader is not null)
			return _cdlLoader.IsCode(offset);
		if (_dizLoader is not null)
			return _dizLoader.IsCode(offset);
		if (_pansyLoader is not null)
			return _pansyLoader.IsCode(offset);
		return null;
	}

	/// <summary>
	/// Checks if an address/offset is data according to CDL/DIZ/Pansy data.
	/// </summary>
	/// <param name="offset">The ROM file offset.</param>
	/// <returns>True if marked as data, null if no CDL/DIZ/Pansy loaded.</returns>
	public bool? IsData(int offset) {
		if (_cdlLoader is not null)
			return _cdlLoader.IsData(offset);
		if (_dizLoader is not null)
			return _dizLoader.IsData(offset);
		if (_pansyLoader is not null)
			return _pansyLoader.IsData(offset);
		return null;
	}

	/// <summary>
	/// Gets memory regions from Pansy data, if available.
	/// Memory regions define address ranges with their types and banks.
	/// </summary>
	public IReadOnlyList<PansyLoader.MemoryRegion>? GetMemoryRegions() =>
		_pansyLoader?.MemoryRegions;

	/// <summary>
	/// Gets the bank number for an address based on Pansy memory regions.
	/// </summary>
	/// <param name="address">The CPU address to look up.</param>
	/// <returns>The bank number, or null if no matching region found.</returns>
	public int? GetBankForAddress(uint address) {
		if (_pansyLoader is null) return null;

		foreach (var region in _pansyLoader.MemoryRegions) {
			if (address >= region.Start && address <= region.End) {
				return region.Bank;
			}
		}
		return null;
	}

	/// <summary>
	/// Gets the memory region containing an address based on Pansy data.
	/// </summary>
	/// <param name="address">The CPU address to look up.</param>
	/// <returns>The memory region, or null if no matching region found.</returns>
	public PansyLoader.MemoryRegion? GetMemoryRegionForAddress(uint address) {
		if (_pansyLoader is null) return null;

		foreach (var region in _pansyLoader.MemoryRegions) {
			if (address >= region.Start && address <= region.End) {
				return region;
			}
		}
		return null;
	}

/// <summary>
/// Load FCEUX .nl (name list) format
/// Format: $XXXX#LabelName#Comment
/// </summary>
private void LoadFceuxNl(string content) {
foreach (var line in content.Split('\n', StringSplitOptions.RemoveEmptyEntries)) {
var trimmed = line.Trim();
if (string.IsNullOrEmpty(trimmed) || !trimmed.StartsWith('$')) continue;

var parts = trimmed.Split('#');
if (parts.Length < 2) continue;

if (uint.TryParse(parts[0][1..], System.Globalization.NumberStyles.HexNumber, null, out var addr)) {
if (!string.IsNullOrWhiteSpace(parts[1]))
_labels[addr] = parts[1].Trim();
if (parts.Length > 2 && !string.IsNullOrWhiteSpace(parts[2]))
_comments[addr] = parts[2].Trim();
}
}
}

/// <summary>
/// Load Mesen .mlb (label) format
/// Format: Type:Address:Name
/// </summary>
private void LoadMesenMlb(string content) {
foreach (var line in content.Split('\n', StringSplitOptions.RemoveEmptyEntries)) {
var trimmed = line.Trim();
if (string.IsNullOrEmpty(trimmed) || trimmed.StartsWith(';')) continue;

var parts = trimmed.Split(':');
if (parts.Length < 3) continue;

var type = parts[0];
if (!uint.TryParse(parts[1], System.Globalization.NumberStyles.HexNumber, null, out var addr))
continue;

var name = parts[2].Trim();
if (string.IsNullOrWhiteSpace(name)) continue;

// Mesen types: P=PRG, C=CHR, R=RAM, G=Register, S=Save
if (type is "P" or "R" or "G") {
_labels[addr] = name;
}
}
}

/// <summary>
/// Load JSON symbol format
/// </summary>
private void LoadJson(string content) {
// Simple JSON parsing without external dependencies
// Expected format: { "labels": { "8000": "reset", ... }, "comments": { ... } }
// For full implementation, use System.Text.Json

var json = System.Text.Json.JsonDocument.Parse(content);
var root = json.RootElement;

if (root.TryGetProperty("labels", out var labels)) {
foreach (var prop in labels.EnumerateObject()) {
if (uint.TryParse(prop.Name, System.Globalization.NumberStyles.HexNumber, null, out var addr)) {
_labels[addr] = prop.Value.GetString() ?? "";
}
}
}

if (root.TryGetProperty("comments", out var comments)) {
foreach (var prop in comments.EnumerateObject()) {
if (uint.TryParse(prop.Name, System.Globalization.NumberStyles.HexNumber, null, out var addr)) {
_comments[addr] = prop.Value.GetString() ?? "";
}
}
}

if (root.TryGetProperty("data", out var data)) {
foreach (var prop in data.EnumerateObject()) {
if (uint.TryParse(prop.Name, System.Globalization.NumberStyles.HexNumber, null, out var addr)) {
var def = prop.Value;
var type = def.GetProperty("type").GetString() ?? "byte";
var count = def.TryGetProperty("count", out var c) ? c.GetInt32() : 1;
var name = def.TryGetProperty("name", out var n) ? n.GetString() : null;
_dataDefinitions[addr] = new DataDefinition(type, count, name);
}
}
}
}

/// <summary>
/// Load generic symbol file format
/// Format: ADDRESS LABEL [; comment]
/// </summary>
private void LoadGenericSym(string content) {
foreach (var line in content.Split('\n', StringSplitOptions.RemoveEmptyEntries)) {
var trimmed = line.Trim();
if (string.IsNullOrEmpty(trimmed) || trimmed.StartsWith(';') || trimmed.StartsWith('#'))
continue;

// Split by whitespace, handling comments
var commentIdx = trimmed.IndexOf(';');
string? comment = null;
if (commentIdx >= 0) {
comment = trimmed[(commentIdx + 1)..].Trim();
trimmed = trimmed[..commentIdx].Trim();
}

var parts = trimmed.Split([' ', '\t', '='], StringSplitOptions.RemoveEmptyEntries);
if (parts.Length < 2) continue;

// Try both orders: ADDR LABEL and LABEL = ADDR
uint addr;
string label;

var addrStr = parts[0].TrimStart('$', '0').TrimStart('x');
if (uint.TryParse(addrStr, System.Globalization.NumberStyles.HexNumber, null, out addr)) {
label = parts[1];
} else {
label = parts[0];
addrStr = parts[^1].TrimStart('$', '0').TrimStart('x');
if (!uint.TryParse(addrStr, System.Globalization.NumberStyles.HexNumber, null, out addr))
continue;
}

_labels[addr] = label;
if (!string.IsNullOrWhiteSpace(comment))
_comments[addr] = comment;
}
}

/// <summary>
/// Add a label manually
/// </summary>
public void AddLabel(uint address, string label) {
_labels[address] = label;
}

/// <summary>
/// Add a bank-specific label
/// </summary>
public void AddBankLabel(int bank, uint address, string label) {
_bankLabels[(bank, address)] = label;
}

/// <summary>
/// Get label for address, checking bank-specific first
/// </summary>
public string? GetLabel(uint address, int bank = -1) {
if (bank >= 0 && _bankLabels.TryGetValue((bank, address), out var bankLabel))
return bankLabel;
return _labels.GetValueOrDefault(address);
}

/// <summary>
/// Get comment for address
/// </summary>
public string? GetComment(uint address) => _comments.GetValueOrDefault(address);
}

/// <summary>
/// Data definition for structured data areas
/// </summary>
public record DataDefinition(string Type, int Count, string? Name);
