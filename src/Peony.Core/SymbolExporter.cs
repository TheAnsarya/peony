using Pansy.Core;

namespace Peony.Core;

/// <summary>
/// Exports symbol/label data to various formats for use with other tools
/// </summary>
public static class SymbolExporter {
	/// <summary>
	/// Export symbols to a file in the specified format
	/// </summary>
	public static void Export(DisassemblyResult result, string outputPath, SymbolFormat format) {
		// Pansy is binary, handle separately
		if (format == SymbolFormat.Pansy) {
			ExportPansy(result, outputPath);
			return;
		}

		var content = format switch {
			SymbolFormat.Mesen => ExportMesen(result),
			SymbolFormat.FCEUX => ExportFCEUX(result),
			SymbolFormat.NoGlasses => ExportNoGlasses(result),
			SymbolFormat.Ca65Debug => ExportCa65Debug(result),
			SymbolFormat.Wla => ExportWla(result),
			SymbolFormat.BizHawk => ExportBizHawk(result),
			_ => throw new ArgumentException($"Unsupported symbol format: {format}")
		};

		File.WriteAllText(outputPath, content);
	}

	/// <summary>
	/// Export symbols to Mesen label format (.mlb)
	/// Format: TYPE:ADDRESS:LABEL or TYPE:STARTADDRESS-ENDADDRESS:LABEL
	/// Where TYPE is: P=PRG, W=Work RAM, S=Save RAM, R=Register, G=Internal RAM (NES), O=OAM
	/// </summary>
	public static string ExportMesen(DisassemblyResult result) {
		var sb = new System.Text.StringBuilder();

		// Export global labels as PRG ROM labels
		foreach (var kvp in result.Labels.OrderBy(x => x.Key)) {
			var address = kvp.Key;
			var label = SanitizeLabel(kvp.Value);

			// Determine label type based on address range
			var type = GetMesenLabelType(address);
			sb.AppendLine($"{type}:{address:x4}:{label}");
		}

		// Export bank-specific labels
		foreach (var kvp in result.BankLabels.OrderBy(x => x.Key.Bank).ThenBy(x => x.Key.Address)) {
			var (address, bank) = kvp.Key;
			var label = SanitizeLabel(kvp.Value);

			// Bank-specific labels use the full address with bank offset
			// For NES: PRG banks are 16KB each
			var fullAddress = address + (uint)(bank * 0x4000);
			sb.AppendLine($"P:{fullAddress:x}:{label}");
		}

		// Export comments if available
		foreach (var kvp in result.Comments.OrderBy(x => x.Key)) {
			var address = kvp.Key;
			var comment = EscapeComment(kvp.Value);
			var type = GetMesenLabelType(address);
			// Mesen uses :Comment suffix
			sb.AppendLine($"{type}:{address:x4}::{comment}");
		}

		return sb.ToString();
	}

	/// <summary>
	/// Export symbols to FCEUX name list format (.nl)
	/// Format: $ADDRESS#LABEL#COMMENT
	/// </summary>
	public static string ExportFCEUX(DisassemblyResult result) {
		var sb = new System.Text.StringBuilder();

		// Combine labels and comments
		var allAddresses = result.Labels.Keys
			.Concat(result.Comments.Keys)
			.Distinct()
			.OrderBy(a => a);

		foreach (var address in allAddresses) {
			var label = result.Labels.TryGetValue(address, out var l) ? SanitizeLabel(l) : "";
			var comment = result.Comments.TryGetValue(address, out var c) ? c : "";

			sb.AppendLine($"${address:x4}#{label}#{comment}");
		}

		// Bank-specific labels with bank suffix
		foreach (var kvp in result.BankLabels.OrderBy(x => x.Key.Bank).ThenBy(x => x.Key.Address)) {
			var (address, bank) = kvp.Key;
			var label = SanitizeLabel(kvp.Value);
			sb.AppendLine($"${address:x4}#{label}_bank{bank}#Bank {bank}");
		}

		return sb.ToString();
	}

	/// <summary>
	/// Export symbols to No$gba/No$sns symbol format (.sym)
	/// Format: ADDRESS LABEL
	/// Supports bank:offset notation for multi-bank ROMs
	/// </summary>
	public static string ExportNoGlasses(DisassemblyResult result) {
		var sb = new System.Text.StringBuilder();

		sb.AppendLine("; No$gba/No$sns Symbol File");
		sb.AppendLine("; Generated by Peony Disassembler");
		sb.AppendLine();

		// Global labels
		foreach (var kvp in result.Labels.OrderBy(x => x.Key)) {
			var address = kvp.Key;
			var label = SanitizeLabel(kvp.Value);
			sb.AppendLine($"{address:x8} {label}");
		}

		// Bank-specific labels (use bank:offset format)
		foreach (var kvp in result.BankLabels.OrderBy(x => x.Key.Bank).ThenBy(x => x.Key.Address)) {
			var (address, bank) = kvp.Key;
			var label = SanitizeLabel(kvp.Value);
			sb.AppendLine($"{bank:x2}:{address:x4} {label}");
		}

		return sb.ToString();
	}

	/// <summary>
	/// Export symbols to ca65 debug format (.dbg)
	/// This is a simplified export that generates a .dbg file compatible with cc65 tools
	/// </summary>
	public static string ExportCa65Debug(DisassemblyResult result) {
		var sb = new System.Text.StringBuilder();

		sb.AppendLine("version\tmajor=2,minor=0");
		sb.AppendLine();
		sb.AppendLine("info\tcsym=0,file=1,lib=0,line=0,mod=1,scope=1,seg=1,span=0,sym=0,type=0");
		sb.AppendLine();

		// File section
		sb.AppendLine($"file\tid=0,name=\"disassembly.s\",size=0,mtime=0,mod=0");
		sb.AppendLine();

		// Module section
		sb.AppendLine($"mod\tid=0,name=\"disassembly.o\",file=0");
		sb.AppendLine();

		// Segment section
		sb.AppendLine($"seg\tid=0,name=\"CODE\",start=0x{result.RomInfo.Metadata.GetValueOrDefault("EntryPoint", "8000")},size={result.RomInfo.Size},addrsize=absolute,type=ro,oname=\"ROM\",ooffs=0");
		sb.AppendLine();

		// Scope section
		sb.AppendLine("scope\tid=0,name=\"\",mod=0,type=scope,size=0,parent=0");
		sb.AppendLine();

		// Labels as symbols
		int symId = 0;
		foreach (var kvp in result.Labels.OrderBy(x => x.Key)) {
			var address = kvp.Key;
			var label = SanitizeLabel(kvp.Value);
			sb.AppendLine($"sym\tid={symId},name=\"{label}\",addrsize=absolute,scope=0,def=0,ref=0,val=0x{address:x},seg=0,type=lab");
			symId++;
		}

		return sb.ToString();
	}

	/// <summary>
	/// Export symbols to WLA-DX symbol format (.sym)
	/// Format: [labels] section with ADDRESS LABEL entries
	/// </summary>
	public static string ExportWla(DisassemblyResult result) {
		var sb = new System.Text.StringBuilder();

		sb.AppendLine("; WLA-DX Symbol File");
		sb.AppendLine("; Generated by Peony Disassembler");
		sb.AppendLine();

		sb.AppendLine("[labels]");

		// Bank-specific format: bank:address label
		if (result.BankLabels.Count > 0) {
			foreach (var kvp in result.BankLabels.OrderBy(x => x.Key.Bank).ThenBy(x => x.Key.Address)) {
				var (address, bank) = kvp.Key;
				var label = SanitizeLabel(kvp.Value);
				sb.AppendLine($"{bank:x2}:{address:x4} {label}");
			}
		}

		// Global labels (bank 0 or unbanked)
		foreach (var kvp in result.Labels.OrderBy(x => x.Key)) {
			var address = kvp.Key;
			var label = SanitizeLabel(kvp.Value);
			sb.AppendLine($"00:{address:x4} {label}");
		}

		return sb.ToString();
	}

	/// <summary>
	/// Export symbols to BizHawk .cht format (compatible with RAM Watch/Cheats)
	/// Also useful for FCEUX cheat format
	/// </summary>
	public static string ExportBizHawk(DisassemblyResult result) {
		var sb = new System.Text.StringBuilder();

		sb.AppendLine("; BizHawk Symbol File");
		sb.AppendLine("; Generated by Peony Disassembler");
		sb.AppendLine();

		// Export RAM labels (addresses < 0x8000 typically)
		foreach (var kvp in result.Labels.Where(x => x.Key < 0x8000).OrderBy(x => x.Key)) {
			var address = kvp.Key;
			var label = SanitizeLabel(kvp.Value);
			sb.AppendLine($"0x{address:x4}\t{label}");
		}

		sb.AppendLine();
		sb.AppendLine("; ROM Labels");

		// ROM labels
		foreach (var kvp in result.Labels.Where(x => x.Key >= 0x8000).OrderBy(x => x.Key)) {
			var address = kvp.Key;
			var label = SanitizeLabel(kvp.Value);
			sb.AppendLine($"0x{address:x4}\t{label}");
		}

		return sb.ToString();
	}

	#region Pansy Export

	// Pansy file constants (matching PansyGenerator/PansyLoader)
	private static readonly byte[] PansyMagic = "PANSY\0\0\0"u8.ToArray();
	private const ushort PansyFormatVersion = 0x0100; // v1.0
	private const uint SECTION_CODE_DATA_MAP = 0x0001;
	private const uint SECTION_SYMBOLS = 0x0002;
	private const uint SECTION_COMMENTS = 0x0003;

	/// <summary>
	/// Export disassembly result to Pansy binary format (.pansy).
	/// This format is compatible with Poppy assembler and provides
	/// comprehensive metadata for roundtrip assembly/disassembly.
	/// </summary>
	public static void ExportPansy(DisassemblyResult result, string outputPath) {
		using var fs = File.Create(outputPath);
		using var writer = new BinaryWriter(fs, System.Text.Encoding.UTF8);

		// Determine platform ID from ROM info
		byte platformId = GetPansyPlatformId(result.RomInfo);

		// Collect section data
		var symbolSection = BuildSymbolSection(result);
		var commentSection = BuildCommentSection(result);
		var codeDataSection = BuildCodeDataSection(result);

		// Calculate section count and offsets
		var sectionCount = 0u;
		if (codeDataSection.Length > 0) sectionCount++;
		if (symbolSection.Length > 0) sectionCount++;
		if (commentSection.Length > 0) sectionCount++;

		var headerSize = 32;
		var sectionTableSize = (int)(sectionCount * 16); // 16 bytes per section entry
		var dataOffset = headerSize + sectionTableSize;

		// Write header (32 bytes)
		writer.Write(PansyMagic);                  // 8 bytes: Magic
		writer.Write(PansyFormatVersion);          // 2 bytes: Version
		writer.Write((ushort)0);                   // 2 bytes: Flags
		writer.Write(platformId);                  // 1 byte: Platform
		writer.Write((byte)0);                     // 1 byte: Reserved
		writer.Write((byte)0);                     // 1 byte: Reserved
		writer.Write((byte)0);                     // 1 byte: Reserved
		writer.Write((uint)(result.RomInfo?.Size ?? 0));  // 4 bytes: ROM size
		writer.Write(0u);                          // 4 bytes: ROM CRC32 (unknown)
		writer.Write(sectionCount);                // 4 bytes: Section count
		writer.Write(0u);                          // 4 bytes: Reserved

		// Write section table
		var currentOffset = (uint)dataOffset;

		if (codeDataSection.Length > 0) {
			writer.Write(SECTION_CODE_DATA_MAP);
			writer.Write(currentOffset);
			writer.Write((uint)codeDataSection.Length);
			writer.Write((uint)codeDataSection.Length);
			currentOffset += (uint)codeDataSection.Length;
		}

		if (symbolSection.Length > 0) {
			writer.Write(SECTION_SYMBOLS);
			writer.Write(currentOffset);
			writer.Write((uint)symbolSection.Length);
			writer.Write((uint)symbolSection.Length);
			currentOffset += (uint)symbolSection.Length;
		}

		if (commentSection.Length > 0) {
			writer.Write(SECTION_COMMENTS);
			writer.Write(currentOffset);
			writer.Write((uint)commentSection.Length);
			writer.Write((uint)commentSection.Length);
		}

		// Write section data
		if (codeDataSection.Length > 0) writer.Write(codeDataSection);
		if (symbolSection.Length > 0) writer.Write(symbolSection);
		if (commentSection.Length > 0) writer.Write(commentSection);
	}

	/// <summary>
	/// Map platform name to Pansy platform ID.
	/// </summary>
	private static byte GetPansyPlatformId(RomInfo? info) {
		if (info?.Platform == null) return 0xff; // Custom/unknown

		return info.Platform.ToLowerInvariant() switch {
			"nes" => PansyLoader.PLATFORM_NES,
			"snes" or "super nintendo" => PansyLoader.PLATFORM_SNES,
			"gb" or "game boy" or "gameboy" => PansyLoader.PLATFORM_GB,
			"gba" or "game boy advance" => PansyLoader.PLATFORM_GBA,
			"genesis" or "mega drive" => PansyLoader.PLATFORM_GENESIS,
			"sms" or "master system" => PansyLoader.PLATFORM_SMS,
			"pce" or "turbografx" or "pc engine" => PansyLoader.PLATFORM_PCE,
			"atari 2600" or "atari2600" or "2600" => PansyLoader.PLATFORM_ATARI_2600,
			"lynx" or "atari lynx" => PansyLoader.PLATFORM_LYNX,
			"wonderswan" or "ws" => PansyLoader.PLATFORM_WONDERSWAN,
			"neogeo" or "neo geo" => PansyLoader.PLATFORM_NEOGEO,
			"spc700" or "spc" => PansyLoader.PLATFORM_SPC700,
			"c64" or "commodore 64" => PansyLoader.PLATFORM_C64,
			"msx" => PansyLoader.PLATFORM_MSX,
			"atari 7800" or "7800" => PansyLoader.PLATFORM_ATARI_7800,
			"atari 8-bit" or "a8" => PansyLoader.PLATFORM_ATARI_8BIT,
			"apple ii" or "apple2" => PansyLoader.PLATFORM_APPLE_II,
			"zx spectrum" or "spectrum" => PansyLoader.PLATFORM_ZX_SPECTRUM,
			"colecovision" or "coleco" => PansyLoader.PLATFORM_COLECO,
			"intellivision" or "intv" => PansyLoader.PLATFORM_INTELLIVISION,
			"vectrex" => PansyLoader.PLATFORM_VECTREX,
			"game gear" or "gg" => PansyLoader.PLATFORM_GAMEGEAR,
			"32x" or "sega 32x" => PansyLoader.PLATFORM_32X,
			"sega cd" or "segacd" => PansyLoader.PLATFORM_SEGACD,
			"virtual boy" or "vb" => PansyLoader.PLATFORM_VIRTUALBOY,
			"amstrad cpc" or "cpc" => PansyLoader.PLATFORM_AMSTRAD_CPC,
			"bbc micro" or "bbc" => PansyLoader.PLATFORM_BBC_MICRO,
			"vic-20" or "vic20" => PansyLoader.PLATFORM_VIC20,
			"plus/4" or "plus4" => PansyLoader.PLATFORM_PLUS4,
			"c128" or "commodore 128" => PansyLoader.PLATFORM_C128,
			_ => PansyLoader.PLATFORM_CUSTOM
		};
	}

	/// <summary>
	/// Build symbol section data.
	/// Format per symbol: address (4) + type (1) + flags (1) + nameLen (2) + name + valueLen (2) [+ value]
	/// </summary>
	private static byte[] BuildSymbolSection(DisassemblyResult result) {
		using var ms = new MemoryStream();
		using var writer = new BinaryWriter(ms, System.Text.Encoding.UTF8);

		// Export global labels
		foreach (var (address, name) in result.Labels.OrderBy(x => x.Key)) {
			writer.Write((uint)address);
			writer.Write((byte)0);  // Type: label
			writer.Write((byte)0);  // Flags
			var nameBytes = System.Text.Encoding.UTF8.GetBytes(name);
			writer.Write((ushort)nameBytes.Length);
			writer.Write(nameBytes);
			writer.Write((ushort)0); // No value
		}

		// Export bank-specific labels with bank in address high byte
		foreach (var ((address, bank), name) in result.BankLabels.OrderBy(x => x.Key.Bank).ThenBy(x => x.Key.Address)) {
			// Encode bank in high byte of 24-bit address
			var addr24 = (uint)((bank << 16) | (int)address);
			writer.Write(addr24);
			writer.Write((byte)1);  // Type: bank label
			writer.Write((byte)0);  // Flags
			var nameBytes = System.Text.Encoding.UTF8.GetBytes(name);
			writer.Write((ushort)nameBytes.Length);
			writer.Write(nameBytes);
			writer.Write((ushort)0); // No value
		}

		return ms.ToArray();
	}

	/// <summary>
	/// Build comment section data.
	/// Format per comment: address (4) + type (1) + textLen (2) + text
	/// </summary>
	private static byte[] BuildCommentSection(DisassemblyResult result) {
		using var ms = new MemoryStream();
		using var writer = new BinaryWriter(ms, System.Text.Encoding.UTF8);

		foreach (var (address, text) in result.Comments.OrderBy(x => x.Key)) {
			writer.Write((uint)address);
			writer.Write((byte)0);  // Type: line comment
			var textBytes = System.Text.Encoding.UTF8.GetBytes(text);
			writer.Write((ushort)textBytes.Length);
			writer.Write(textBytes);
		}

		return ms.ToArray();
	}

	/// <summary>
	/// Build code/data map section from disassembly blocks.
	/// Each byte: 0x00=unreached, 0x01=code, 0x02=data, 0x11=opcode
	/// </summary>
	private static byte[] BuildCodeDataSection(DisassemblyResult result) {
		if (result.RomInfo?.Size == null || result.RomInfo.Size == 0)
			return [];

		var map = new byte[result.RomInfo.Size];

		foreach (var block in result.Blocks) {
			foreach (var line in block.Lines) {
				// Determine offset from address (platform-specific)
				var offset = GetRomOffset(line.Address, result.RomInfo);
				if (offset < 0 || offset >= map.Length) continue;

				if (block.Type == MemoryRegion.Code) {
					// First byte is opcode, rest are operands
					for (var i = 0; i < line.Bytes.Length && offset + i < map.Length; i++) {
						map[offset + i] = (byte)(i == 0 ? 0x11 : 0x01); // 0x11 = Code + Opcode
					}
				} else if (block.Type == MemoryRegion.Data) {
					for (var i = 0; i < line.Bytes.Length && offset + i < map.Length; i++) {
						map[offset + i] = 0x02; // Data
					}
				}
			}
		}

		return map;
	}

	/// <summary>
	/// Convert CPU address to ROM file offset (platform-specific).
	/// </summary>
	private static int GetRomOffset(uint address, RomInfo info) {
		var platform = info.Platform?.ToLowerInvariant() ?? "";

		return platform switch {
			"nes" => (int)(address - 0x8000 + 16), // Account for 16-byte iNES header
			"snes" => ConvertSnesAddressToOffset(address, info),
			"gb" or "gameboy" or "game boy" => (int)address, // Usually 1:1 mapping
			"gba" or "game boy advance" => (int)(address - 0x08000000), // GBA ROM base
			_ => (int)address // Default: direct mapping
		};
	}

	/// <summary>
	/// Convert SNES CPU address to ROM offset based on mapping mode.
	/// </summary>
	private static int ConvertSnesAddressToOffset(uint address, RomInfo info) {
		var bank = (int)(address >> 16);
		var offset = (int)(address & 0xffff);

		// Check mapping mode from mapper name
		var isHiROM = info.Mapper?.Contains("HiROM", StringComparison.OrdinalIgnoreCase) == true;

		if (isHiROM) {
			// HiROM: banks $C0-$FF map linearly, $40-$7D mirror
			if (bank >= 0xC0) {
				return ((bank - 0xC0) * 0x10000) + offset;
			} else if (bank >= 0x40 && bank < 0x7E) {
				return ((bank - 0x40) * 0x10000) + offset;
			}
		} else {
			// LoROM: $8000-$FFFF of each bank, banks $80-$FF map to $00-$7F
			if (offset >= 0x8000) {
				var realBank = bank >= 0x80 ? bank - 0x80 : bank;
				return (realBank * 0x8000) + (offset - 0x8000);
			}
		}

		return (int)address; // Fallback
	}

	#endregion

	/// <summary>
	/// Determine Mesen label type based on address
	/// </summary>
	private static char GetMesenLabelType(uint address) {
		return address switch {
			< 0x0800 => 'G',  // Internal RAM (first 2KB mirrored)
			< 0x2000 => 'G',  // Internal RAM mirrors
			< 0x4000 => 'R',  // PPU registers
			< 0x4020 => 'R',  // APU/IO registers
			< 0x6000 => 'P',  // Expansion ROM
			< 0x8000 => 'S',  // Save RAM / Work RAM
			_ => 'P'          // PRG ROM
		};
	}

	/// <summary>
	/// Sanitize label for compatibility with symbol formats
	/// </summary>
	private static string SanitizeLabel(string label) {
		// Replace invalid characters with underscores
		var result = new System.Text.StringBuilder();
		foreach (var c in label) {
			if (char.IsLetterOrDigit(c) || c == '_' || c == '.') {
				result.Append(c);
			} else {
				result.Append('_');
			}
		}

		// Ensure label doesn't start with a digit
		if (result.Length > 0 && char.IsDigit(result[0])) {
			result.Insert(0, '_');
		}

		return result.ToString();
	}

	/// <summary>
	/// Escape comment for formats that support inline comments
	/// </summary>
	private static string EscapeComment(string comment) {
		return comment
			.Replace("\r", "")
			.Replace("\n", " ")
			.Replace("#", "")
			.Replace(":", "");
	}
}

/// <summary>
/// Supported symbol export formats
/// </summary>
public enum SymbolFormat {
	/// <summary>Mesen emulator (.mlb)</summary>
	Mesen,

	/// <summary>FCEUX emulator (.nl)</summary>
	FCEUX,

	/// <summary>No$gba/No$sns (.sym)</summary>
	NoGlasses,

	/// <summary>ca65 debug format (.dbg)</summary>
	Ca65Debug,

	/// <summary>WLA-DX assembler (.sym)</summary>
	Wla,

	/// <summary>BizHawk (.cht)</summary>
	BizHawk,

	/// <summary>Pansy metadata file (.pansy) - Poppy/Peony interchange</summary>
	Pansy
}
