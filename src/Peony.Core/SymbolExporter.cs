namespace Peony.Core;

/// <summary>
/// Exports symbol/label data to various formats for use with other tools
/// </summary>
public static class SymbolExporter {
	/// <summary>
	/// Export symbols to a file in the specified format
	/// </summary>
	public static void Export(DisassemblyResult result, string outputPath, SymbolFormat format) {
		var content = format switch {
			SymbolFormat.Mesen => ExportMesen(result),
			SymbolFormat.FCEUX => ExportFCEUX(result),
			SymbolFormat.NoGlasses => ExportNoGlasses(result),
			SymbolFormat.Ca65Debug => ExportCa65Debug(result),
			SymbolFormat.Wla => ExportWla(result),
			SymbolFormat.BizHawk => ExportBizHawk(result),
			_ => throw new ArgumentException($"Unsupported symbol format: {format}")
		};

		File.WriteAllText(outputPath, content);
	}

	/// <summary>
	/// Export symbols to Mesen label format (.mlb)
	/// Format: TYPE:ADDRESS:LABEL or TYPE:STARTADDRESS-ENDADDRESS:LABEL
	/// Where TYPE is: P=PRG, W=Work RAM, S=Save RAM, R=Register, G=Internal RAM (NES), O=OAM
	/// </summary>
	public static string ExportMesen(DisassemblyResult result) {
		var sb = new System.Text.StringBuilder();

		// Export global labels as PRG ROM labels
		foreach (var kvp in result.Labels.OrderBy(x => x.Key)) {
			var address = kvp.Key;
			var label = SanitizeLabel(kvp.Value);

			// Determine label type based on address range
			var type = GetMesenLabelType(address);
			sb.AppendLine($"{type}:{address:x4}:{label}");
		}

		// Export bank-specific labels
		foreach (var kvp in result.BankLabels.OrderBy(x => x.Key.Bank).ThenBy(x => x.Key.Address)) {
			var (address, bank) = kvp.Key;
			var label = SanitizeLabel(kvp.Value);

			// Bank-specific labels use the full address with bank offset
			// For NES: PRG banks are 16KB each
			var fullAddress = address + (uint)(bank * 0x4000);
			sb.AppendLine($"P:{fullAddress:x}:{label}");
		}

		// Export comments if available
		foreach (var kvp in result.Comments.OrderBy(x => x.Key)) {
			var address = kvp.Key;
			var comment = EscapeComment(kvp.Value);
			var type = GetMesenLabelType(address);
			// Mesen uses :Comment suffix
			sb.AppendLine($"{type}:{address:x4}::{comment}");
		}

		return sb.ToString();
	}

	/// <summary>
	/// Export symbols to FCEUX name list format (.nl)
	/// Format: $ADDRESS#LABEL#COMMENT
	/// </summary>
	public static string ExportFCEUX(DisassemblyResult result) {
		var sb = new System.Text.StringBuilder();

		// Combine labels and comments
		var allAddresses = result.Labels.Keys
			.Concat(result.Comments.Keys)
			.Distinct()
			.OrderBy(a => a);

		foreach (var address in allAddresses) {
			var label = result.Labels.TryGetValue(address, out var l) ? SanitizeLabel(l) : "";
			var comment = result.Comments.TryGetValue(address, out var c) ? c : "";

			sb.AppendLine($"${address:x4}#{label}#{comment}");
		}

		// Bank-specific labels with bank suffix
		foreach (var kvp in result.BankLabels.OrderBy(x => x.Key.Bank).ThenBy(x => x.Key.Address)) {
			var (address, bank) = kvp.Key;
			var label = SanitizeLabel(kvp.Value);
			sb.AppendLine($"${address:x4}#{label}_bank{bank}#Bank {bank}");
		}

		return sb.ToString();
	}

	/// <summary>
	/// Export symbols to No$gba/No$sns symbol format (.sym)
	/// Format: ADDRESS LABEL
	/// Supports bank:offset notation for multi-bank ROMs
	/// </summary>
	public static string ExportNoGlasses(DisassemblyResult result) {
		var sb = new System.Text.StringBuilder();

		sb.AppendLine("; No$gba/No$sns Symbol File");
		sb.AppendLine("; Generated by Peony Disassembler");
		sb.AppendLine();

		// Global labels
		foreach (var kvp in result.Labels.OrderBy(x => x.Key)) {
			var address = kvp.Key;
			var label = SanitizeLabel(kvp.Value);
			sb.AppendLine($"{address:x8} {label}");
		}

		// Bank-specific labels (use bank:offset format)
		foreach (var kvp in result.BankLabels.OrderBy(x => x.Key.Bank).ThenBy(x => x.Key.Address)) {
			var (address, bank) = kvp.Key;
			var label = SanitizeLabel(kvp.Value);
			sb.AppendLine($"{bank:x2}:{address:x4} {label}");
		}

		return sb.ToString();
	}

	/// <summary>
	/// Export symbols to ca65 debug format (.dbg)
	/// This is a simplified export that generates a .dbg file compatible with cc65 tools
	/// </summary>
	public static string ExportCa65Debug(DisassemblyResult result) {
		var sb = new System.Text.StringBuilder();

		sb.AppendLine("version\tmajor=2,minor=0");
		sb.AppendLine();
		sb.AppendLine("info\tcsym=0,file=1,lib=0,line=0,mod=1,scope=1,seg=1,span=0,sym=0,type=0");
		sb.AppendLine();

		// File section
		sb.AppendLine($"file\tid=0,name=\"disassembly.s\",size=0,mtime=0,mod=0");
		sb.AppendLine();

		// Module section
		sb.AppendLine($"mod\tid=0,name=\"disassembly.o\",file=0");
		sb.AppendLine();

		// Segment section
		sb.AppendLine($"seg\tid=0,name=\"CODE\",start=0x{result.RomInfo.Metadata.GetValueOrDefault("EntryPoint", "8000")},size={result.RomInfo.Size},addrsize=absolute,type=ro,oname=\"ROM\",ooffs=0");
		sb.AppendLine();

		// Scope section
		sb.AppendLine("scope\tid=0,name=\"\",mod=0,type=scope,size=0,parent=0");
		sb.AppendLine();

		// Labels as symbols
		int symId = 0;
		foreach (var kvp in result.Labels.OrderBy(x => x.Key)) {
			var address = kvp.Key;
			var label = SanitizeLabel(kvp.Value);
			sb.AppendLine($"sym\tid={symId},name=\"{label}\",addrsize=absolute,scope=0,def=0,ref=0,val=0x{address:x},seg=0,type=lab");
			symId++;
		}

		return sb.ToString();
	}

	/// <summary>
	/// Export symbols to WLA-DX symbol format (.sym)
	/// Format: [labels] section with ADDRESS LABEL entries
	/// </summary>
	public static string ExportWla(DisassemblyResult result) {
		var sb = new System.Text.StringBuilder();

		sb.AppendLine("; WLA-DX Symbol File");
		sb.AppendLine("; Generated by Peony Disassembler");
		sb.AppendLine();

		sb.AppendLine("[labels]");

		// Bank-specific format: bank:address label
		if (result.BankLabels.Count > 0) {
			foreach (var kvp in result.BankLabels.OrderBy(x => x.Key.Bank).ThenBy(x => x.Key.Address)) {
				var (address, bank) = kvp.Key;
				var label = SanitizeLabel(kvp.Value);
				sb.AppendLine($"{bank:x2}:{address:x4} {label}");
			}
		}

		// Global labels (bank 0 or unbanked)
		foreach (var kvp in result.Labels.OrderBy(x => x.Key)) {
			var address = kvp.Key;
			var label = SanitizeLabel(kvp.Value);
			sb.AppendLine($"00:{address:x4} {label}");
		}

		return sb.ToString();
	}

	/// <summary>
	/// Export symbols to BizHawk .cht format (compatible with RAM Watch/Cheats)
	/// Also useful for FCEUX cheat format
	/// </summary>
	public static string ExportBizHawk(DisassemblyResult result) {
		var sb = new System.Text.StringBuilder();

		sb.AppendLine("; BizHawk Symbol File");
		sb.AppendLine("; Generated by Peony Disassembler");
		sb.AppendLine();

		// Export RAM labels (addresses < 0x8000 typically)
		foreach (var kvp in result.Labels.Where(x => x.Key < 0x8000).OrderBy(x => x.Key)) {
			var address = kvp.Key;
			var label = SanitizeLabel(kvp.Value);
			sb.AppendLine($"0x{address:x4}\t{label}");
		}

		sb.AppendLine();
		sb.AppendLine("; ROM Labels");

		// ROM labels
		foreach (var kvp in result.Labels.Where(x => x.Key >= 0x8000).OrderBy(x => x.Key)) {
			var address = kvp.Key;
			var label = SanitizeLabel(kvp.Value);
			sb.AppendLine($"0x{address:x4}\t{label}");
		}

		return sb.ToString();
	}

	/// <summary>
	/// Determine Mesen label type based on address
	/// </summary>
	private static char GetMesenLabelType(uint address) {
		return address switch {
			< 0x0800 => 'G',  // Internal RAM (first 2KB mirrored)
			< 0x2000 => 'G',  // Internal RAM mirrors
			< 0x4000 => 'R',  // PPU registers
			< 0x4020 => 'R',  // APU/IO registers
			< 0x6000 => 'P',  // Expansion ROM
			< 0x8000 => 'S',  // Save RAM / Work RAM
			_ => 'P'          // PRG ROM
		};
	}

	/// <summary>
	/// Sanitize label for compatibility with symbol formats
	/// </summary>
	private static string SanitizeLabel(string label) {
		// Replace invalid characters with underscores
		var result = new System.Text.StringBuilder();
		foreach (var c in label) {
			if (char.IsLetterOrDigit(c) || c == '_' || c == '.') {
				result.Append(c);
			} else {
				result.Append('_');
			}
		}

		// Ensure label doesn't start with a digit
		if (result.Length > 0 && char.IsDigit(result[0])) {
			result.Insert(0, '_');
		}

		return result.ToString();
	}

	/// <summary>
	/// Escape comment for formats that support inline comments
	/// </summary>
	private static string EscapeComment(string comment) {
		return comment
			.Replace("\r", "")
			.Replace("\n", " ")
			.Replace("#", "")
			.Replace(":", "");
	}
}

/// <summary>
/// Supported symbol export formats
/// </summary>
public enum SymbolFormat {
	/// <summary>Mesen emulator (.mlb)</summary>
	Mesen,

	/// <summary>FCEUX emulator (.nl)</summary>
	FCEUX,

	/// <summary>No$gba/No$sns (.sym)</summary>
	NoGlasses,

	/// <summary>ca65 debug format (.dbg)</summary>
	Ca65Debug,

	/// <summary>WLA-DX assembler (.sym)</summary>
	Wla,

	/// <summary>BizHawk (.cht)</summary>
	BizHawk
}
